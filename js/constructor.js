//============================== EDITOR =============================

var editor = {};

editor.variables = {
  canvasWidth: 0,
  canvasHeight: 0,
};

editor.canvases = {};
editor.contexts = {};
//editor.canvases: front, rear, sides
//editor.contexts: front, rear, sides

editor.state = {
  shirtColor: "#ff0000",
  lastShirtColor: "#ff0000",
  currentTool: "",
  content: {},
  absoluteX: 0,
  absoluteY: 0,
  monument: "images/front1.png",

  //Coordinates relative to editor.state.canvas
  relativeX: 0,
  relativeY: 0,

  //Canvas ("front", "rear" or "sides"), over which the preview is
  // canvas: "front",

  //Absolute width and height of preview canvas
  sizeX: 0,
  sizeY: 0,

  //Width and height of preview canvas relative to editor.variables.canvasWidth and editor.variables.canvasHeight
  relativeSizeX: 0,
  relativeSizeY: 0,

  //When tool is used and new tool is picked, editor.toolUsed() changes id of current preview canvas from "preview" to editor.state.previewId
  //When new tool is picked, editor.useTool() changes editor.state.previewId to new string value generated by Math.random()
  previewId: "",

  changes: 0,
  noCanvasError: false,

  newPreviewId: function () {
    var min = 0;
    var max = Number.MAX_SAFE_INTEGER;
    editor.state.previewId = "" + Math.floor(Math.random() * (max - min) + min);
  },
};

editor.updateMonument = function (newMonument) {
  console.log("Updating monument to:", newMonument);

  const previousMonument = editor.state.monument;
  editor.state.monument = newMonument; // Обновляем путь к новому изображению

  const monumentPrices = {
    "images/front1.png": 10000,
    "images/front2.png": 12000,
    "images/front3.png": 9000,
    "images/front4.png": 11000,
    "images/front5.png": 9500,
    "images/front6.png": 10000,
    "images/front7.png": 12000,
    "images/front8.png": 9000,
    "images/front9.png": 11000,
    "images/front10.png": 9500,
    "images/front11.png": 10000,
    "images/front12.png": 12000,
  };

  // Удаляем предыдущий монумент из списка стоимости
  if (previousMonument && previousMonument !== newMonument) {
    priceCalculator.removeAllMonuments();
  }

  // Добавляем новый монумент в список стоимости
  const price = monumentPrices[newMonument] || 0;
  priceCalculator.addItem(newMonument, price);

  editor.drawMonument(); // Перерисовываем канвас
};

editor.drawMonument = function () {
  const canvas = editor.canvases.front; // Используем канвас 'front'
  const context = editor.contexts.front;

  if (!canvas || !context) {
    console.error("Canvas or context not found.");
    return;
  }

  // Устанавливаем размеры канваса, если они не заданы
  canvas.width = editor.variables.canvasWidth || 600;
  canvas.height = editor.variables.canvasHeight || 450;

  // Очищаем канвас перед новой отрисовкой
  context.clearRect(0, 0, canvas.width, canvas.height);

  if (!editor.state.monument) {
    // Если изображение не выбрано, выводим текст
    context.font = "20px Arial";
    context.fillStyle = "#333";
    context.textAlign = "center";
    context.textBaseline = "middle";

    context.fillText(
      "Выберите изображение памятника снизу",
      canvas.width / 2,
      canvas.height / 2
    );
  } else {
    // Загружаем изображение памятника
    const img = new Image();
    img.onload = function () {
      // Устанавливаем целевую высоту изображения, которая должна быть меньше высоты канваса
      const targetHeight = canvas.height * 0.9; // 90% от высоты канваса

      // Вычисляем коэффициент масштабирования по высоте
      const scale = targetHeight / img.height;

      // Ширина изображения, сохраняющая пропорции
      const targetWidth = img.width * scale;

      // Координаты для центрирования изображения
      const x = (canvas.width - targetWidth) / 2;
      const y = (canvas.height - targetHeight) / 2;

      // Отрисовываем изображение с заданными размерами
      context.drawImage(img, x, y, targetWidth, targetHeight);
    };
    img.src = editor.state.monument;
  }
};

editor.preparePage = function () {
  const viewportWidth = window.innerWidth; // Получаем ширину экрана
  const viewportHeight = window.innerHeight; // Получаем высоту экрана

  // Если ширина экрана меньше 1200 пикселей, не уменьшаем ширину канваса
  const canvasWidth =
    viewportWidth > 1200 ? viewportWidth - 300 : viewportWidth;

  // Высота канваса = 90% от высоты экрана
  const canvasHeight = viewportHeight * 0.85;

  const referenceWidth = 1000;
  const referenceHeight = 400;
  const aspectRatio = referenceHeight / referenceWidth;

  // Корректируем ширину канваса, чтобы сохранить соотношение сторон
  const calculatedHeight = canvasWidth * aspectRatio;

  // Если рассчитанная высота больше 90% от высоты экрана, то ограничиваем высоту канваса 90vh
  if (calculatedHeight > canvasHeight) {
    const scaleFactor = canvasHeight / calculatedHeight;
    const adjustedWidth = canvasWidth * scaleFactor;
    const adjustedHeight = canvasHeight;

    // Применяем новые размеры канваса с сохранением пропорций
    $("#canvasDiv1").css({
      width: `${adjustedWidth}px`,
      height: `${adjustedHeight}px`,
    });

    editor.variables.canvasWidth = adjustedWidth;
    editor.variables.canvasHeight = adjustedHeight;
  } else {
    // Если рассчитанная высота укладывается в 90vh, используем ее
    $("#canvasDiv1").css({
      width: `${canvasWidth}px`,
      height: `${canvasHeight}px`,
    });

    editor.variables.canvasWidth = canvasWidth;
    editor.variables.canvasHeight = canvasHeight;
  }

  console.log("Canvas updated:", { canvasWidth, canvasHeight });
};

editor.createCanvas = function (element) {
  var canvas = document.createElement("canvas");
  element.appendChild(canvas);
  canvas.setAttribute("width", $(element).width());
  canvas.setAttribute("height", element.style.height);
  return canvas;
};

editor.drawFill = function () {
  var whiteColor = "#FFFFFF"; // Устанавливаем белый цвет
  for (var ctx in editor.contexts) {
    var context = editor.contexts[ctx];
    context.fillStyle = whiteColor; // Используем белый цвет
    context.fillRect(
      0,
      0,
      editor.variables.canvasWidth,
      editor.variables.canvasHeight
    );
  }
};

editor.drawMasks = function () {
  for (var ctx in editor.contexts) {
    var texture = new Image();
    texture.src = "images/" + ctx + ".png";

    texture.onload = (function (texture, ctx) {
      return function () {
        var canvas = editor.canvases[ctx];
        var context = editor.contexts[ctx];

        // Получаем размеры канваса
        var canvasWidth = canvas.width;
        var canvasHeight = canvas.height;

        // Получаем исходные размеры изображения
        var imgWidth = texture.width;
        var imgHeight = texture.height;

        // Вычисляем коэффициенты для сохранения пропорций
        var widthRatio = canvasWidth / imgWidth;
        var heightRatio = canvasHeight / imgHeight;
        var ratio = Math.min(widthRatio, heightRatio); // Выбираем меньший коэффициент

        // Вычисляем новые размеры изображения
        var newWidth = imgWidth * ratio;
        var newHeight = imgHeight * ratio;

        // Вычисляем позицию для центрирования изображения
        var xOffset = (canvasWidth - newWidth) / 2;
        var yOffset = (canvasHeight - newHeight) / 2;

        // Очищаем канвас перед отрисовкой
        context.clearRect(0, 0, canvasWidth, canvasHeight);

        // Рисуем изображение с новыми размерами и смещением
        context.drawImage(texture, xOffset, yOffset, newWidth, newHeight);
      };
    })(texture, ctx);
  }
};

editor.activateTools = function () {
  //Add event listeners on tools buttons
  $(".tool").each(function (index) {
    if ($(this).attr("id") == "render") {
      $(this).on("click", function () {
        $(this).tooltip("hide");
        openInNewTab("");
      });
    } else {
      $(this).on("click", function () {
        editor.useTool($(this).attr("id"));
      });
    }
    $(this).tooltip();
  });
};

editor.updateRelativeCoords = function () {
  //get
  //editor.state.absoluteX and editor.state.absoluteY, editor.state.sizeX and editor.state.sizeY
  //set
  //editor.state.canvas, editor.state.relativeX and editor.state.relativeY,
  //editor.state.relativeSizeX and editor.state.relativeSizeY

  var absX = editor.state.absoluteX;
  var absY = editor.state.absoluteY;
  var sizeX = editor.state.sizeX;
  var sizeY = editor.state.sizeY;

  var centerX = absX + sizeX / 2;
  var centerY = absY + sizeY / 2;

  //determine over which canvas preview is located
  var canvasList = {};

  for (var canvas in editor.canvases) {
    var can = editor.canvases[canvas];
    var c = {};
    c.offset = absoluteOffset(can);
    c.startX = c.offset.left;
    c.startY = c.offset.top;
    c.endX = c.startX + $(can).width();
    c.endY = c.startY + $(can).height();
    c.width = $(can).width();
    c.height = $(can).height();
    canvasList[canvas] = c;
  }

  var canvas = "none";

  for (var c in canvasList) {
    var can = canvasList[c];
    if (
      centerX >= can.startX &&
      centerX <= can.endX &&
      centerY >= can.startY &&
      centerY <= can.endY
    ) {
      canvas = c;
      break;
    }
  }
  //"canvas" variable now is "none", "front", "rear" or "sides"
  if (canvas == "none") {
    editor.state.canvas = "none";
    return;
  }

  //calculate preview offset from this canvas
  var can = canvasList[canvas];
  var absOffsetX = absX - can.startX;
  var absOffsetY = absY - can.startY;

  //and make them relative
  var relOffsetX = absOffsetX / canvasList[canvas].width;
  var relOffsetY = absOffsetX / canvasList[canvas].height;

  //calculate relative size of preview
  var relSizeX = sizeX / canvasList[canvas].width;
  var relSizeY = sizeY / canvasList[canvas].height;

  editor.state.canvas = canvas;
  editor.state.relativeX = relOffsetX;
  editor.state.relativeY = relOffsetY;
  editor.state.relativeSizeX = relSizeX;
  editor.state.relativeSizeY = relSizeY;
};

editor.toolUsed = function () {
  //When new tool is picked, disable .draggable and .resizable for current preview canvas and save changes made by the previous tool to history

  var toolsWithPreview = [
    "addpicture", // Добавить картинку
    "photo",
    "addtextfio", // Добавить ФИО
    "addtextdate", // Добавить ФИО
    "epitaph", // Добавить эпитафию
    "cross", // Добавить крестик
    "flower", // Добавить цветок
    "candle", // Добавить свечу
    "bird", // Добавить птицу
    "vignette", // Добавить виньетку
  ];

  var toolsWithoutPreview = [
    "color", // Инструмент для изменения цвета
  ];

  if (toolsWithPreview.indexOf(editor.state.currentTool) != -1) {
    if (!$("#preview")[0]) return;

    var coords = absoluteOffset($("#preview")[0]);
    editor.state.absoluteX = coords.left;
    editor.state.absoluteY = coords.top;

    // Устанавливаем фиксированные размеры 80x80 пикселей
    editor.state.sizeX = 80;
    editor.state.sizeY = 80;

    editor.updateRelativeCoords();

    if (editor.state.canvas == "none") {
      editor.state.noCanvasError = true;
      editor.noCanvasError();
      $("#preview").remove();
    } else {
      history.newEntry(
        true,
        editor.state.currentTool,
        editor.state.content,
        editor.state.relativeX,
        editor.state.relativeY,
        editor.state.canvas,
        editor.state.relativeSizeX,
        editor.state.relativeSizeY,
        editor.state.previewId
      );

      editor.state.changes++;

      if ($("#preview").is(".ui-resizable")) {
        $("#preview").resizable("destroy");
      } else {
        $("#preview").draggable("destroy");
      }
      $("#preview").css("cursor", "auto").attr("id", editor.state.previewId);
    }
  }

  if (toolsWithoutPreview.indexOf(editor.state.currentTool) != -1) {
    history.newEntry(false, editor.state.currentTool);

    editor.state.changes++;
  }
};

editor.useTool = function (tool) {
  editor.state.newPreviewId();
  editor.toolUsed();

  if (editor.state.noCanvasError) return;

  editor.state.currentTool = tool;
  if (!(tool == "render")) {
    $("#modalOpener").click();
    editor.tools[tool]();
  }
};

editor.previewToShirt = function () {
  $("#preview").appendTo($("body")).center().css("cursor", "move").draggable();
  $("#modal").modal("hide");
};

editor.noCanvasError = function () {
  $("#modalOpener").click();
  $("#cancelbutton").remove();
  $("#okbutton")
    .text("OK")
    .click(function () {
      $("#modal").modal("hide");
      editor.state.noCanvasError = false;
    });
  $("#modalTitle").text("Ошибка");
  ReactDOM.render(
    <NoCanvasErrorMessage />,
    document.getElementById("modalBody")
  );
};

editor.renderPng = function (win) {
  html2canvas(document.body, {
    onrendered: function (canvas) {
      if (win) {
        win.focus();
        $(win.document.body).html("");
        win.document.body.appendChild(canvas);
      } else {
        alert("Разрешите всплывающие окна на этом сайте!");
      }
    },
  });
};

editor.init = function () {
  editor.preparePage();
  editor.canvases.front = editor.createCanvas(
    document.getElementById("canvasDiv1")
  );

  for (var canvas in editor.canvases) {
    editor.contexts[canvas] = editor.canvases[canvas].getContext("2d");
  }

  editor.drawFill(editor.state.shirtColor);
  editor.drawMasks();
  editor.activateTools();
};

//================================ UTILS ===================================

/*
The canvas element runs independent from the device or monitor's pixel ratio.
On the iPad 3+, this ratio is 2. This essentially means that your 1000px width canvas would now need to fill 2000px to match it's stated width on the iPad display. Fortunately for us, this is done automatically by the browser. On the other hand, this is also the reason why you see less definition on images and canvas elements that were made to directly fit their visible area. Because your canvas only knows how to fill 1000px but is asked to draw to 2000px, the browser must now intelligently fill in the blanks between pixels to display the element at its proper size.
*/
//MyNameIsKo
//http://stackoverflow.com/questions/15661339/how-do-i-fix-blurry-text-in-my-html5-canvas

var PIXEL_RATIO = (function () {
  var ctx = document.createElement("canvas").getContext("2d"),
    dpr = window.devicePixelRatio || 1,
    bsr =
      ctx.webkitBackingStorePixelRatio ||
      ctx.mozBackingStorePixelRatio ||
      ctx.msBackingStorePixelRatio ||
      ctx.oBackingStorePixelRatio ||
      ctx.backingStorePixelRatio ||
      1;

  return dpr / bsr;
})();

var createHiDPICanvas = function (w, h, ratio) {
  if (!ratio) {
    ratio = PIXEL_RATIO;
  }
  var can = document.createElement("canvas");
  can.width = w * ratio;
  can.height = h * ratio;
  can.style.width = w + "px";
  can.style.height = h + "px";
  can.pixelRatio = ratio;
  can.getContext("2d").setTransform(ratio, 0, 0, ratio, 0, 0);
  return can;
};

//Create canvas with the device resolution.
//var myCanvas = createHiDPICanvas(500, 250);

var triggerOnchange = function (element) {
  var event = new Event("input", { bubbles: true });
  element.dispatchEvent(event);
};

jQuery.fn.center = function () {
  this.css("position", "absolute");
  this.css(
    "top",
    Math.max(
      0,
      ($(window).height() - $(this).outerHeight()) / 2 + $(window).scrollTop()
    ) + "px"
  );
  this.css(
    "left",
    Math.max(
      0,
      ($(window).width() - $(this).outerWidth()) / 2 + $(window).scrollLeft()
    ) + "px"
  );
  return this;
};

$.widget("ui.resizable", $.ui.resizable, {
  resizeTo: function (newSize) {
    var start = new $.Event("mousedown", { pageX: 0, pageY: 0 });
    this._mouseStart(start);
    this.axis = "se";
    var end = new $.Event("mouseup", {
      pageX: newSize.width - this.originalSize.width,
      pageY: newSize.height - this.originalSize.height,
    });
    this._mouseDrag(end);
    this._mouseStop(end);
  },
});

var absoluteOffset = function (element) {
  var top = 0,
    left = 0;
  do {
    top += element.offsetTop || 0;
    left += element.offsetLeft || 0;
    element = element.offsetParent;
  } while (element);

  return {
    top: top,
    left: left,
  };
};

function openInNewTab(url) {
  var win = window.open(url, "_blank");
  win.focus();
  win.document.write("<div id='loading'><b>Загрузка...</b></div>");
  editor.renderPng(win);
}

//=============================== TOOLS ======================================

editor.tools = {
  addtextfio: function () {
    $("#modalTitle").text("Добавить ФИО");
    ReactDOM.render(
      <AddTextFIO tool="addtextfio" />,
      document.getElementById("modalBody")
    );
  },

  addtextdate: function () {
    $("#modalTitle").text("Добавить дату");
    ReactDOM.render(
      <AddTextDate tool="addtextdate" />,
      document.getElementById("modalBody")
    );
  },

  addpicture: function () {
    $("#modalTitle").text("Добавить картинку");
    ReactDOM.render(
      <AddPicture tool="addpicture" />,
      document.getElementById("modalBody")
    );
  },

  photo: function () {
    $("#modalTitle").text("Выбрать фотографию");
    ReactDOM.render(
      <Photo tool="photo" />,
      document.getElementById("modalBody")
    );
  },

  epitaph: function () {
    $("#modalTitle").text("Выбрать эпитафию");
    ReactDOM.render(
      <Photo tool="epitaph" />,
      document.getElementById("modalBody")
    );
  },

  cross: function () {
    $("#modalTitle").text("Выбрать крестик");
    ReactDOM.render(
      <Photo tool="cross" />,
      document.getElementById("modalBody")
    );
  },

  flower: function () {
    $("#modalTitle").text("Выбрать цветок");
    ReactDOM.render(
      <Photo tool="flower" />,
      document.getElementById("modalBody")
    );
  },

  candle: function () {
    $("#modalTitle").text("Выбрать свечу");
    ReactDOM.render(
      <Photo tool="candle" />,
      document.getElementById("modalBody")
    );
  },

  bird: function () {
    $("#modalTitle").text("Выбрать птицу");
    ReactDOM.render(
      <Photo tool="bird" />,
      document.getElementById("modalBody")
    );
  },

  vignette: function () {
    $("#modalTitle").text("Выбрать виньетку");
    ReactDOM.render(
      <Photo tool="vignette" />,
      document.getElementById("modalBody")
    );
  },

  undo: function () {
    $("#modalTitle").text("Отменить последнее действие");
    $("#okbutton").text("Да");
    ReactDOM.render(<Undo />, document.getElementById("modalBody"));
    $("#okbutton").click(function () {
      $("#modal").modal("hide");
      history.undo();
    });
  },

  clearall: function () {
    $("#modalTitle").text("Очистить всё");
    $("#okbutton").text("Да");
    ReactDOM.render(<Clearall />, document.getElementById("modalBody"));
    $("#okbutton").click(function () {
      $("#modal").modal("hide");
      history.clearall();
    });
  },
};
//=============================  HISTORY  =====================================

//All coordinates in history are relative

var history = {};

history.changes = [];

var Change = function (withPreview, tool, content, x, y, canvas, sizeX, sizeY) {
  if (withPreview) {
    this.tool = tool;
    this.content = content;
    this.x = x;
    this.y = y;
    this.sizeX = sizeX;
    this.sizeY = sizeY;
    this.canvas = canvas;
    this.previewId = editor.state.previewId;

    this.comment = "Added element on canvas '" + this.canvas + "'";

    return this;
  } else if (!withPreview) {
    this.tool = tool;

    if (this.tool == "color") {
      this.oldColor = editor.state.lastShirtColor;
      this.newColor = editor.state.shirtColor;
      this.comment =
        "T-shirt color changed from " + this.oldColor + "to " + this.newColor;
    }

    return this;
  }
};

history.newEntry = function (
  tool,
  content,
  x,
  y,
  canvas,
  sizeX,
  sizeY,
  previewId
) {
  console.log("Saving new entry to history:", { tool, content, previewId });
  var entry = new Change(tool, content, x, y, canvas, sizeX, sizeY, previewId);
  history.changes.push(entry);

  console.log(entry.comment);
};

history.undo = function () {
  if (history.changes.length < 1) {
    return;
  }

  const lastChange = history.changes.pop();
  console.log("Undoing change:", lastChange); // Debug log

  if (lastChange.previewId && $(`#${lastChange.previewId}`).length) {
    // Remove the element from DOM
    $(`#${lastChange.previewId}`).remove();

    // Handle price removal based on tool type
    switch (lastChange.tool) {
      case "addtextfio":
        priceCalculator.removeItem("name");
        break;
      case "addtextdate":
        priceCalculator.removeItem("date");
        break;
      case "addpicture":
        priceCalculator.removeItem("addpicture");
        break;
      case "photo":
      case "epitaph":
      case "cross":
      case "flower":
      case "candle":
      case "bird":
      case "vignette":
        // For sidebar elements, we need to extract the image name from the content
        if (lastChange.content) {
          // If content is an object with image property (from uploaded images)
          if (lastChange.content.image) {
            const imageSrc = lastChange.content.image.src;
            const imageName = imageSrc.split("/").pop();
            priceCalculator.removeItem(imageName);
          }
          // If content is a string (direct image path)
          else if (typeof lastChange.content === "string") {
            const imageName = lastChange.content.split("/").pop();
            priceCalculator.removeItem(imageName);
          }
          // If content has a src property (from selected images)
          else if (lastChange.content.src) {
            const imageName = lastChange.content.src.split("/").pop();
            priceCalculator.removeItem(imageName);
          }
        }
        break;
    }
  }
};

history.clearall = function () {
  while (history.changes.length > 0) {
    history.undo();
  }
  // Clear any remaining elements from the DOM
  $("[id^=preview]").remove();
  // Reset the price calculator
  priceCalculator.items = {};
  priceCalculator.totalPrice = 0;
  priceCalculator.updatePriceList();
};
//==============================  REACT  =======================================

//----------------- tool dialogs --------------------

// Компонент для добавления ФИО
var AddTextFIO = React.createClass({
  getInitialState: function () {
    return {
      error: "", // Состояние для хранения сообщения об ошибке
    };
  },

  componentDidMount: function () {
    $(".fontlist").each(function (index) {
      $(this).css("font-family", $(this).text());
    });

    $("#colorpicker").spectrum({
      color: "#000000",
      cancelText: "Отмена",
      chooseText: "Выбрать",
      change: function (color) {
        $("#hexcolor").val(color.toHexString().substr(1, 6));
        triggerOnchange($("#hexcolor")[0]);
      },
    });

    $("#hexcolor").change(function () {
      $("#colorpicker").spectrum("set", $("#hexcolor").val());
      triggerOnchange($("#hexcolor")[0]);
    });

    $("#modal").on("shown.bs.modal", function () {
      var width = $("#previewDiv").width();
      var height = $("#previewDiv").height();
      var canvas = createHiDPICanvas(width, height);
      canvas.id = "preview";
      $(canvas).appendTo("#previewDiv");
    });

    $("#okbutton").click(() => {
      if ($("#text").val() !== "") {
        editor.previewToShirt();
        // Add price for name when added
        priceCalculator.addItem("name");
      } else {
        this.setState({ error: "Поле не должно быть пустым." });
      }
    });
  },

  handleChange: function () {
    this.setState({ error: "" }); // Сбрасываем ошибку при вводе текста
    this.updatePreview();
  },

  updatePreview: function (clearall) {
    var canvas = document.getElementById("preview");
    var context = canvas.getContext("2d");
    var text = $("#text").val();

    // Проверка регулярным выражением
    const isValid =
      /^[a-zA-Zа-яА-ЯёЁ\-\s]{2,50}$/.test(text) &&
      text.trim().split(/\s+/).length >= 2 &&
      text.trim().split(/\s+/).length <= 5;

    if (!isValid) {
      this.setState({
        error: "Введите от 2 до 5 слов, используя буквы и дефис.",
      });
      return;
    }

    if (clearall) text = "";
    var font = $("#fontpicker").val();
    var size = $("#sizepicker").val();
    var color = $("#colorpicker").spectrum("get");

    context.font = size + "px " + font;
    var textWidth = context.measureText(text).width;
    var textHeight = size;

    textWidth *= canvas.pixelRatio;
    textHeight *= canvas.pixelRatio;

    var x = canvas.width / 2 - textWidth / 2;
    var y = canvas.height / 2 + textHeight / 2;

    x /= canvas.pixelRatio;
    y /= canvas.pixelRatio;

    context.clearRect(0, 0, canvas.width, canvas.height);

    if (color.toHexString) var hexColor = color.toHexString();
    context.fillStyle = 0 || hexColor;
    context.fillText(text, x, y);

    editor.state.content = {
      text: text,
      font: font,
      size: size,
      color: hexColor,
      x: x,
      y: y,
    };
  },

  render: function () {
    return (
      <div onChange={this.handleChange} id="addtextfio">
        <div className="container-fluid">
          <TextArea updatePreview={this.updatePreview} />
          {this.state.error && (
            <p style={{ color: "red", fontSize: "14px" }}>{this.state.error}</p>
          )}
        </div>

        <div className="container-fluid">
          <div className="col-xs-6 col-sm-6 col-md-6 col-lg-4 smallinput">
            <FontSizePicker />
          </div>

          <div className="col-xs-6 col-sm-6 col-md-6 col-lg-8 smallinput">
            <FontList fonts={resources.fonts} />
          </div>
        </div>

        <div className="container-fluid">
          <div className="colorpicker-label">Выберите цвет текста</div>
          <div className="colorpicker">
            <ColorPicker id="colorpicker" />
          </div>
          <div>
            <div className="input-group hexcolor">
              <span className="input-group-addon">#</span>
              <input
                type="text"
                className="form-control"
                id="hexcolor"
                maxLength="6"
              />
            </div>
          </div>
        </div>

        <div className="container-fluid">
          <div
            className="col-xs-12 col-sm-12 col-md-12 col-lg-10 preview"
            id="previewDiv"
          ></div>
        </div>
      </div>
    );
  },
});

var AddTextDate = React.createClass({
  getInitialState: function () {
    return {
      error: "", // Состояние для сообщения об ошибке
    };
  },

  componentDidMount: function () {
    $(".fontlist").each(function (index) {
      $(this).css("font-family", $(this).text());
    });

    $("#colorpicker").spectrum({
      color: "#000000",
      cancelText: "Отмена",
      chooseText: "Выбрать",
      change: function (color) {
        $("#hexcolor").val(color.toHexString().substr(1, 6));
        triggerOnchange($("#hexcolor")[0]);
      },
    });

    $("#hexcolor").change(function () {
      $("#colorpicker").spectrum("set", $("#hexcolor").val());
      triggerOnchange($("#hexcolor")[0]);
    });

    $("#modal").on("shown.bs.modal", function () {
      var width = $("#previewDiv").width();
      var height = $("#previewDiv").height();
      var canvas = createHiDPICanvas(width, height);
      canvas.id = "preview";
      $(canvas).appendTo("#previewDiv");
    });

    $("#okbutton").click(() => {
      if ($("#text").val() !== "") {
        editor.previewToShirt();
        // Add price for date when added
        priceCalculator.addItem("date");
      } else {
        this.setState({ error: "Поле не должно быть пустым." });
      }
    });
  },

  handleChange: function () {
    this.setState({ error: "" }); // Сбрасываем ошибку при вводе текста
    this.updatePreview();
  },

  updatePreview: function (clearall) {
    var canvas = document.getElementById("preview");
    var context = canvas.getContext("2d");
    var text = $("#text").val();

    // Проверка регулярным выражением
    const isValid = /^\d{2}\.\d{2}\.\d{4}(\s-\s\d{2}\.\d{2}\.\d{4})?$/.test(
      text
    );
    if (!isValid) {
      this.setState({
        error:
          "Введите дату в формате ДД.ММ.ГГГГ или диапазон через дефис (ДД.ММ.ГГГГ - ДД.ММ.ГГГГ).",
      });
      return;
    }

    if (clearall) text = "";
    var font = $("#fontpicker").val();
    var size = $("#sizepicker").val();
    var color = $("#colorpicker").spectrum("get");

    context.font = size + "px " + font;
    var textWidth = context.measureText(text).width;
    var textHeight = size;

    textWidth *= canvas.pixelRatio;
    textHeight *= canvas.pixelRatio;

    var x = canvas.width / 2 - textWidth / 2;
    var y = canvas.height / 2 + textHeight / 2;

    x /= canvas.pixelRatio;
    y /= canvas.pixelRatio;

    context.clearRect(0, 0, canvas.width, canvas.height);

    if (color.toHexString) var hexColor = color.toHexString();
    context.fillStyle = 0 || hexColor;
    context.fillText(text, x, y);

    editor.state.content = {
      text: text,
      font: font,
      size: size,
      color: hexColor,
      x: x,
      y: y,
    };
  },

  render: function () {
    return (
      <div onChange={this.handleChange} id="addtextdate">
        <div className="container-fluid">
          <TextArea updatePreview={this.updatePreview} />
          {this.state.error && (
            <p style={{ color: "red", fontSize: "14px" }}>{this.state.error}</p>
          )}
        </div>

        <div className="container-fluid">
          <div className="col-xs-6 col-sm-6 col-md-6 col-lg-4 smallinput">
            <FontSizePicker />
          </div>

          <div className="col-xs-6 col-sm-6 col-md-6 col-lg-8 smallinput">
            <FontList fonts={resources.fonts} />
          </div>
        </div>

        <div className="container-fluid">
          <div className="colorpicker-label">Выберите цвет текста</div>
          <div className="colorpicker">
            <ColorPicker id="colorpicker" />
          </div>
          <div>
            <div className="input-group hexcolor">
              <span className="input-group-addon">#</span>
              <input
                type="text"
                className="form-control"
                id="hexcolor"
                maxLength="6"
              />
            </div>
          </div>
        </div>

        <div className="container-fluid">
          <div
            className="col-xs-12 col-sm-12 col-md-12 col-lg-10 preview"
            id="previewDiv"
          ></div>
        </div>
      </div>
    );
  },
});

var AddPicture = React.createClass({
  componentDidMount: function () {
    var imageLoader = document.getElementById("imageLoader");
    imageLoader.addEventListener("change", this.handleImage, false);
  },

  handleImage: function (e) {
    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");

    var reader = new FileReader();

    reader.onload = (event) => {
      var img = new Image();

      img.onload = () => {
        // Фиксируем высоту изображения на 100 пикселей
        var fixedHeight = 350;

        // Вычисляем ширину с учетом пропорций
        var ratio = img.width / img.height;
        var fixedWidth = fixedHeight * ratio;

        // Устанавливаем размеры канваса в соответствии с вычисленными размерами
        canvas.width = fixedWidth;
        canvas.height = fixedHeight;

        // Рисуем изображение с новыми размерами
        context.drawImage(img, 0, 0, fixedWidth, fixedHeight);

        // Добавляем canvas на страницу
        $(canvas)
          .appendTo($("body"))
          .attr("id", "preview")
          .center()
          .resizable({
            aspectRatio: true,
            handles: "n, e, s, w, ne, se, sw, nw",
          })
          .css("cursor", "move")
          .closest("div")
          .draggable({ containment: "parent" });

        // Масштабируем изображение, если оно слишком большое
        var w = window.innerWidth;
        var h = window.innerHeight;

        if (canvas.width > w - 100 || canvas.height > h - 150) {
          var ratio = img.width / img.height;
          var newWidth, newHeight;

          if (ratio > 1) {
            newWidth = w * 0.7;
            newHeight = newWidth / ratio;
          } else {
            newHeight = h * 0.6;
            newWidth = newHeight * ratio;
          }

          $(canvas).resizable("resizeTo", {
            height: newHeight,
            width: newWidth,
          });
          $(canvas).closest("div").center();
        }

        // Закрываем модальное окно
        $("#modal").modal("hide");

        // Сохраняем в редактор
        editor.state.content = {
          image: img,
          sizeX: fixedWidth,
          sizeY: fixedHeight,
          type: "addpicture", // Add type to identify this is from addpicture
        };

        // Add price for uploaded image
        priceCalculator.addItem("addpicture", 5000);
      };

      img.src = event.target.result;
    };
    reader.readAsDataURL(e.target.files[0]);
  },

  render: function () {
    return (
      <div>
        <div className="container-fluid">
          <h4>Загрузите изображение:</h4>
        </div>

        <EmptyContainer />

        <div className="container-fluid">
          <input type="file" id="imageLoader" name="imageLoader" />
        </div>
      </div>
    );
  },
});

var Photo = React.createClass({
  getInitialState: function () {
    return {
      selectedImage: null, // Выбранное изображение
    };
  },

  componentDidMount: function () {
    // Обработчик для кнопки "Готово"
    $("#okbutton").click(() => {
      if (this.state.selectedImage) {
        this.addImageToCanvas(this.state.selectedImage);
      }
    });
  },

  handleImageSelect: function (imgSrc) {
    console.log("Selected image: ", imgSrc); // Логирование выбранного изображения
    this.setState({ selectedImage: imgSrc });
  },

  addImageToCanvas: function (imgSrc) {
    const imagePrices = {
      "photo1.png": 7000,
      "photo2.png": 8000,
      "photo3.png": 6000,
      "photo4.png": 7500,
      "epitaph1.png": 4000,
      "epitaph2.png": 4500,
      "epitaph3.png": 4200,
      "cross1.png": 1000,
      "cross2.png": 1000,
      "cross3.png": 1000,
      "cross4.png": 1000,
      "cross5.png": 1000,
      "cross6.png": 1000,
      "cross7.png": 1000,
      "cross8.png": 1000,
      "flower1.png": 1000,
      "flower2.png": 1000,
      "flower3.png": 1000,
      "flower4.png": 1000,
      "flower5.png": 1000,
      "flower6.png": 1000,
      "flower7.png": 1000,
      "flower8.png": 1000,
      "candle1.png": 1000,
      "candle2.png": 1000,
      "candle3.png": 1000,
      "candle4.png": 1000,
      "candle5.png": 1000,
      "candle6.png": 1000,
      "candle7.png": 1000,
      "candle8.png": 1000,
      "candle9.png": 1000,
      "bird1.png": 4000,
      "bird2.png": 4200,
      "bird3.png": 4400,
      "bird4.png": 4000,
      "bird5.png": 4200,
      "bird6.png": 4400,
      "bird7.png": 4000,
      "bird8.png": 4200,
      "bird9.png": 4400,
      "vignette1.png": 2000,
      "vignette2.png": 2000,
      "vignette3.png": 2000,
    };
    // Извлекаем цену на основе имени изображения
    const imageName = imgSrc.split("/").pop(); // Получаем имя изображения (например, flower.png)
    const price = imagePrices[imageName] || 0; // Получаем цену из объекта или 0, если цена не найдена

    // Добавляем цену в калькулятор
    priceCalculator.addItem(imageName, price);

    // Создаем canvas для отображения изображения
    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");
    var img = new Image();

    img.onload = function () {
      // Фиксируем высоту изображения на 100 пикселей
      var fixedHeight = 350;

      // Вычисляем ширину с учетом пропорций
      var ratio = img.width / img.height;
      var fixedWidth = fixedHeight * ratio;

      // Устанавливаем размеры канваса в соответствии с новыми размерами изображения
      canvas.width = fixedWidth;
      canvas.height = fixedHeight;

      // Рисуем изображение на канвасе с сохранением пропорций
      context.drawImage(img, 0, 0, fixedWidth, fixedHeight);

      // Добавляем canvas на страницу
      $(canvas)
        .appendTo($("body"))
        .attr("id", "preview")
        .center()
        .resizable({
          aspectRatio: true,
          handles: "n, e, s, w, ne, se, sw, nw",
        })
        .css("cursor", "move")
        .closest("div")
        .draggable({ containment: "parent" });

      // Закрываем модальное окно
      $("#modal").modal("hide");

      // Сохраняем в редактор
      editor.state.content = {
        image: img,
        sizeX: fixedWidth, // Используем вычисленные размеры
        sizeY: fixedHeight, // Используем фиксированную высоту
      };
    };

    img.src = imgSrc; // Загружаем изображение
  },

  render: function () {
    // Список изображений для текущего инструмента
    const images = {
      photo: [
        "images/photo1.png",
        "images/photo2.png",
        "images/photo3.png",
        "images/photo4.png",
      ],
      epitaph: [
        "images/epitaph1.png",
        "images/epitaph2.png",
        "images/epitaph3.png",
        "images/epitaph4.png",
        "images/epitaph5.png",
        "images/epitaph6.png",
        "images/epitaph7.png",
        "images/epitaph8.png",
        "images/epitaph9.png",
        "images/epitaph10.png",
        "images/epitaph11.png",
        "images/epitaph12.png",
        "images/epitaph13.png",
      ],
      cross: [
        "images/cross1.png",
        "images/cross2.png",
        "images/cross3.png",
        "images/cross4.png",
        "images/cross5.png",
        "images/cross6.png",
        "images/cross7.png",
        "images/cross8.png",
      ],
      flower: [
        "images/flower1.png",
        "images/flower2.png",
        "images/flower3.png",
        "images/flower4.png",
        "images/flower5.png",
        "images/flower6.png",
        "images/flower7.png",
        "images/flower8.png",
      ],
      candle: [
        "images/candle1.png",
        "images/candle2.png",
        "images/candle3.png",
        "images/candle4.png",
        "images/candle5.png",
        "images/candle6.png",
        "images/candle7.png",
        "images/candle8.png",
        "images/candle9.png",
      ],
      bird: [
        "images/bird1.png",
        "images/bird2.png",
        "images/bird3.png",
        "images/bird4.png",
        "images/bird5.png",
        "images/bird6.png",
        "images/bird7.png",
        "images/bird8.png",
        "images/bird9.png",
      ],
      vignette: [
        "images/vignette1.png",
        "images/vignette2.png",
        "images/vignette3.png",
        "images/vignette4.png",
        "images/vignette5.png",
        "images/vignette6.png",
        "images/vignette7.png",
        "images/vignette8.png",
        "images/vignette9.png",
        "images/vignette10.png",
        "images/vignette11.png",
        "images/vignette12.png",
        "images/vignette13.png",
        "images/vignette14.png",
        "images/vignette15.png",
        "images/vignette16.png",
        "images/vignette17.png",
        "images/vignette18.png",
        "images/vignette19.png",
        "images/vignette20.png",
      ],
    };

    // Получаем изображения для текущего инструмента
    const imageList = images[this.props.tool] || [];
    const isEpitaph = this.props.tool === "epitaph";

    return (
      <div>
        <div className="container-fluid"></div>
        <EmptyContainer />
        <div className="container-fluid">
          <div className="image-list-container">
            <ul className="image-list">
              {imageList.map((src, index) => (
                <img
                  key={index}
                  src={src}
                  alt={`${this.props.tool} ${index + 1}`}
                  className={`thumbnail ${
                    this.state.selectedImage === src ? "selected" : ""
                  }`}
                  onClick={() => this.handleImageSelect(src)}
                  style={{
                    backgroundColor: "#1e2c5c",
                    cursor: "pointer",
                    border:
                      this.state.selectedImage === src
                        ? "2px solid blue"
                        : "1px solid gray",
                    margin: "5px",
                    width: isEpitaph ? "200px" : "100px", // Увеличиваем размер для epitaph
                    height: isEpitaph ? "200px" : "100px", // Пропорциональное увеличение
                  }}
                />
              ))}
            </ul>
          </div>
        </div>
      </div>
    );
  },
});

var ChangeColor = React.createClass({
  componentDidMount: function () {
    this.colorBeforeChanges = editor.state.shirtColor;

    $("#colorpicker").spectrum({
      color: editor.state.shirtColor,
      cancelText: "Отмена",
      chooseText: "Выбрать",
      change: function (color) {
        $("#hexcolor").val(color.toHexString().substr(1, 6));
        triggerOnchange($("#hexcolor")[0]);
      },
    });
    $("#hexcolor").change(function () {
      $("#colorpicker").spectrum("set", $("#hexcolor").val());
      triggerOnchange($("#hexcolor")[0]);
    });

    $("#okbutton").click(function () {
      $("#modal").modal("hide");
    });

    var updateShirtColor = this.updateShirtColor;
    var colorBeforeChanges = this.colorBeforeChanges;
    $("#cancelbutton").click(function () {
      editor.state.shirtColor = colorBeforeChanges;
      updateShirtColor();
      $("#modal").modal("hide");
    });
  },

  handleChange: function () {
    var color = $("#colorpicker").spectrum("get");
    var hexColor = color.toHexString();
    editor.state.shirtColor = hexColor;
    this.updateShirtColor();
  },

  updateShirtColor: function () {
    editor.drawFill(editor.state.shirtColor);
    editor.drawMasks();
  },

  render: function () {
    return (
      <div onChange={this.handleChange}>
        <div className="container-fluid">
          <div className="colorpicker-label">Выберите цвет футболки</div>
          <div className="colorpicker">
            <ColorPicker id="colorpicker" />
          </div>
          <div>
            <div className="input-group hexcolor">
              <span className="input-group-addon">#</span>
              <input
                type="text"
                className="form-control"
                id="hexcolor"
                maxLength="6"
              />
            </div>
          </div>
        </div>
      </div>
    );
  },
});

var AddFigure = React.createClass({
  componentDidMount: function () {
    $("#colorpicker").spectrum({
      color: "#000000",
      cancelText: "Отмена",
      chooseText: "Выбрать",
      change: function (color) {
        $("#hexcolor").val(color.toHexString().substr(1, 6));
        triggerOnchange($("#hexcolor")[0]);
      },
    });
    $("#hexcolor").change(function () {
      $("#colorpicker").spectrum("set", $("#hexcolor").val());
      triggerOnchange($("#hexcolor")[0]);
    });

    $("#colorpicker2").spectrum({
      color: "#eeeeee",
      cancelText: "Отмена",
      chooseText: "Выбрать",
      change: function (color) {
        $("#hexcolor2").val(color.toHexString().substr(1, 6));
        triggerOnchange($("#hexcolor2")[0]);
      },
    });
    $("#hexcolor2").change(function () {
      $("#colorpicker2").spectrum("set", $("#hexcolor2").val());
      triggerOnchange($("#hexcolor2")[0]);
    });

    $("#xsizepicker").slider({
      min: 2,
      max: 300,
      animate: "fast",
      value: 50,
      change: function () {
        triggerOnchange($("#hexcolor")[0]);
      },
    });
    $("#ysizepicker").slider({
      min: 2,
      max: 300,
      animate: "fast",
      value: 50,
      change: function () {
        triggerOnchange($("#hexcolor")[0]);
      },
    });
    $("#linewidth").val("1");

    var updatePreview = this.updatePreview;
    $("#modal").on("shown.bs.modal", function () {
      var width = $("#previewDiv").width();
      var height = $("#previewDiv").height();
      var canvas = createHiDPICanvas(width, height);
      canvas.id = "preview";
      $(canvas).appendTo("#previewDiv");
      updatePreview();
    });

    $("#okbutton").click(function () {
      editor.previewToShirt();
    });
  },

  handleChange: function () {
    this.updatePreview();
  },

  updatePreview: function () {
    var canvas = document.getElementById("preview");
    var context = canvas.getContext("2d");
    var canvasWidth = $("#previewDiv").width();
    var canvasHeight = $("#previewDiv").height();

    var figure = $("#figurepicker").val();
    var lineWidth = $("#linewidth").val();
    var width = $("#xsizepicker").slider("value");
    var height = $("#ysizepicker").slider("value");
    var strokeColor = $("#colorpicker").spectrum("get");
    var fillColor = $("#colorpicker2").spectrum("get");

    var x = canvas.width / 2 - width / 2;
    var y = canvas.height / 2 - height / 2;
    width /= canvas.pixelRatio;
    height /= canvas.pixelRatio;
    x /= canvas.pixelRatio;
    y /= canvas.pixelRatio;

    if (strokeColor.toHexString) var hexStrokeColor = strokeColor.toHexString();
    if (fillColor.toHexString) var hexFillColor = fillColor.toHexString();

    if ($("#nostroke").is(":checked")) hexStrokeColor = "rgba(0,0,0,0)";
    if ($("#nofill").is(":checked")) hexFillColor = "rgba(0,0,0,0)";

    context.strokeStyle = hexStrokeColor;
    context.fillStyle = hexFillColor;
    context.lineWidth = lineWidth;

    context.clearRect(0, 0, canvas.width, canvas.height);

    //draw figure

    if (figure == "rectangle") {
      context.beginPath();
      context.rect(x, y, width, height);
      context.closePath();
      context.fill();
      context.stroke();
    } else if (figure == "triangle") {
      context.beginPath();
      context.moveTo(x, y + height);
      context.lineTo(x + width, y + height);
      context.lineTo(canvasWidth / 2, y);
      context.closePath();
      context.fill();
      context.stroke();
    } else if (figure == "ellipse") {
      context.save();
      context.beginPath();
      if (width > 280) {
        var safeWidth = 280;
      } else {
        var safeWidth = width;
      }
      if (height > 150) {
        var safeHeight = 170;
      } else {
        var safeHeight = height;
      }
      context.ellipse(
        x + width / 2,
        y + height / 2,
        safeWidth,
        safeHeight,
        0,
        0,
        Math.PI * 2
      );
      context.closePath();
      context.fill();
      context.stroke();
      context.restore();
    }

    editor.state.content = {
      figure: figure,
      width: width,
      height: height,
      strokeColor: hexStrokeColor,
      fillColor: hexFillColor,
      x: x,
      y: y,
    };
  },

  render: function () {
    return (
      <div onChange={this.handleChange} id="addfigurediv">
        <div className="container-fluid">
          <div className="col-xs-6 col-sm-6 col-md-6 col-lg-8 smallinput">
            <FigureList />
          </div>
        </div>

        <div className="container-fluid">
          <div className="colorpicker-label">Выберите цвет обводки:</div>
          <div className="colorpicker">
            <ColorPicker id="colorpicker" />
          </div>
          <div>
            <div className="input-group hexcolor">
              <span className="input-group-addon">#</span>
              <input
                type="text"
                className="form-control"
                id="hexcolor"
                maxLength="6"
              />
            </div>
          </div>
          <div className="col-xs-6 col-sm-6 col-md-4 col-lg-3 smallinput">
            <div className="checkbox right">
              <label>
                <input type="checkbox" value="" id="nostroke" />
                Без обводки
              </label>
            </div>
          </div>
        </div>

        <div className="container-fluid">
          <div className="colorpicker-label">Выберите цвет заливки:</div>
          <div className="colorpicker">
            <ColorPicker id="colorpicker2" />
          </div>
          <div>
            <div className="input-group hexcolor">
              <span className="input-group-addon">#</span>
              <input
                type="text"
                className="form-control"
                id="hexcolor2"
                maxLength="6"
              />
            </div>
          </div>
          <div className="col-xs-6 col-sm-6 col-md-4 col-lg-3 smallinput">
            <div className="checkbox right">
              <label>
                <input type="checkbox" value="" id="nofill" />
                Без заливки
              </label>
            </div>
          </div>
        </div>

        <div className="container-fluid">
          <div className="colorpicker-label">Толщина обводки:</div>
          <div className="input-group linewidth">
            <input
              type="number"
              className="form-control"
              id="linewidth"
              maxLength="1"
              min="1"
              max="7"
            />
            <span className="input-group-addon">px</span>
          </div>
        </div>

        <div className="container-fluid">
          <div className="table table-condensed table-bordered table-responsive">
            <table className="table">
              <tbody>
                <tr>
                  <td>Ширина</td>
                  <td>Высота</td>
                </tr>
                <tr>
                  <td>
                    <div className="slider">
                      <div id="xsizepicker"></div>
                    </div>
                  </td>
                  <td>
                    <div className="slider">
                      <div id="ysizepicker"></div>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="container-fluid">
          <div
            className="col-xs-12 col-sm-12 col-md-12 col-lg-10 preview-big"
            id="previewDiv"
          ></div>
        </div>
      </div>
    );
  },
});

var Undo = React.createClass({
  render: function () {
    return <div className="container-fluid">Отменить последнее изменение?</div>;
  },
});

var Clearall = React.createClass({
  render: function () {
    return <div className="container-fluid">Очистить макет?</div>;
  },
});

//------------------ resources --------------------

var resources = {};

resources.fonts = [
  "Georgia, serif",
  '"Palatino Linotype", "Book Antiqua", Palatino, serif',
  '"Times New Roman", Times, serif',
  "Arial, Helvetica, sans-serif",
  '"Arial Black", Gadget, sans-serif',
  '"Comic Sans MS", cursive, sans-serif',
  "Impact, Charcoal, sans-serif",
  '"Lucida Sans Unicode", "Lucida Grande", sans-serif',
  "Tahoma, Geneva, sans-serif",
  '"Trebuchet MS", Helvetica, sans-serif',
  "Verdana, Geneva, sans-serif",
  '"Courier New", Courier, monospace',
  '"Lucida Console", Monaco, monospace',
];

resources.tools = [
  {
    id: "photo",
    label: "Фотография", // Текст для кнопки "Фотография"
  },
  {
    id: "addpicture",
    label: "Вложения", // Текст для кнопки "Вложения"
  },
  {
    id: "addtextfio",
    label: "ФИО", // Текст для кнопки "ФИО"
  },
  {
    id: "addtextdate",
    label: "Дата", // Текст для кнопки "ФИО"
  },
  {
    id: "epitaph",
    label: "Эпитафия", // Текст для кнопки "Эпитафия"
  },
  {
    id: "cross",
    label: "Крестик", // Текст для кнопки "Крестик"
  },
  {
    id: "flower",
    label: "Цветок", // Текст для кнопки "Цветок"
  },
  {
    id: "candle",
    label: "Свеча", // Текст для кнопки "Свеча"
  },
  {
    id: "bird",
    label: "Пейзаж", // Текст для кнопки "Птица"
  },
  {
    id: "vignette",
    label: "Виньетка", // Текст для кнопки "Виньетка"
  },
  {
    id: "undo",
    label: "Назад", // Текст для кнопки Назад
  },
  {
    id: "clearall",
    label: "Очистить все", // Текст для кнопки Очистить все
  },
  {
    id: "render",
    label: "Сохранить картинку",
  },
];

//-------------- tool dialogs classes -------------

var ListItemWrapper = React.createClass({
  render: function () {
    return <li className={this.props.classname}>{this.props.item}</li>;
  },
});

var SelectItemWrapper = React.createClass({
  render: function () {
    return (
      <option className={this.props.classname} value={this.props.item}>
        {this.props.name}
      </option>
    );
  },
});

var TextArea = React.createClass({
  getInitialState: function () {
    return { value: "" };
  },

  handleChange: function (event) {
    this.setState({ value: event.target.value });
  },

  clearall: function () {
    this.setState({ value: "" });
    this.props.updatePreview(true);
  },

  render: function () {
    var text = this.state.value;
    return (
      <div className="input-group">
        <input
          type="text"
          className="form-control"
          placeholder="Введите текст"
          aria-describedby="cleartext"
          id="text"
          onChange={this.handleChange}
          value={text}
        />

        <span
          className="input-group-addon"
          onClick={this.clearall}
          id="cleartext"
        >
          <span className="glyphicon glyphicon-remove-circle"></span>
        </span>
      </div>
    );
  },
});

var FontList = React.createClass({
  getInitialState: function () {
    return { value: this.props.fonts[0] };
  },

  handleChange: function (event) {
    this.setState({ value: event.target.value });
  },

  render: function () {
    var currentFont = this.state.value;
    return (
      <select
        value={currentFont}
        onChange={this.handleChange}
        className="form-control select"
        id="fontpicker"
      >
        {this.props.fonts.map(function (font) {
          return (
            <SelectItemWrapper
              key={font}
              classname="fontlist"
              item={font}
              name={font}
            />
          );
        })}
      </select>
    );
  },
});

var FigureList = React.createClass({
  figures: function () {
    return [
      { type: "rectangle", name: "Прямоугольник" },
      { type: "triangle", name: "Треугольник" },
      { type: "ellipse", name: "Эллипс" },
    ];
  },

  getInitialState: function () {
    return { value: "rectangle" };
  },

  handleChange: function (event) {
    this.setState({ value: event.target.value });
  },

  render: function () {
    var currentFigure = this.state.value;
    var figures = this.figures();
    return (
      <select
        value={currentFigure}
        onChange={this.handleChange}
        className="form-control select"
        id="figurepicker"
      >
        {figures.map(function (figure) {
          return (
            <SelectItemWrapper
              key={figure.type}
              classname="figurelist"
              item={figure.type}
              name={figure.name}
            />
          );
        })}
      </select>
    );
  },
});

var FontSizePicker = React.createClass({
  getInitialState: function () {
    return { value: "18" };
  },

  handleChange: function (event) {
    this.setState({ value: event.target.value });
  },

  render: function () {
    var text = this.state.value;
    return (
      <div className="input-group">
        <input
          type="number"
          className="form-control"
          placeholder="Введите размер шрифта"
          onChange={this.handleChange}
          value={text}
          id="sizepicker"
        />

        <span className="input-group-addon">px</span>
      </div>
    );
  },
});

var ColorPicker = React.createClass({
  render: function () {
    return <input type="text" id={this.props.id} />;
  },
});

var NoCanvasErrorMessage = React.createClass({
  render: function () {
    return (
      <div className="container-fluid">
        Предыдущий элемент был помещен вне какого-либо макета и будет удален.
      </div>
    );
  },
});

//---------- main components classes -------------

var ToolButtons = React.createClass({
  handleButtonClick: function (tool) {
    // Вызываем соответствующую функцию из editor.tools
    if (editor.tools[tool.id]) {
      editor.tools[tool.id](); // Вызов функции по идентификатору
    }
  },

  render: function () {
    return (
      <div>
        {/* Блок для "Фотография" и "Вложения" */}
        <div className="tool-block">
          <p className="tool-description">ВЫБЕРИТЕ ВАРИАНТ ПОРТРЕТА</p>
          <ul className="nav">
            {this.props.tools.slice(0, 2).map(function (tool) {
              return (
                <li
                  className="nav-item"
                  key={tool.id}
                  style={{ marginBottom: "4px" }}
                >
                  <button
                    type="button"
                    className="tool"
                    data-toggle="tooltip"
                    title={tool.tooltip}
                    id={tool.id}
                    data-placement="bottom"
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                    }} // Flexbox для расположения
                    onClick={() => this.handleButtonClick(tool)} // Обработчик клика
                  >
                    <p className="tool-label">{tool.label}</p>
                    {/* SVG элемент */}
                    <svg
                      width="50"
                      height="5"
                      viewBox="0 0 50 5"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M47.6155 0L46.9171 0.707031L48.1942 2H0V3H48.0247L46.9171 4.12134L47.6155 4.82837L50 2.41431L47.6155 0Z"
                        fill="white"
                      />
                    </svg>
                  </button>
                </li>
              );
            }, this)}{" "}
            {/* Добавлено 'this' для доступа к контексту */}
          </ul>
        </div>

        {/* Блок для "ФИО" и "Даты" */}
        <div className="tool-block">
          <p className="tool-description">ДОБАВЬТЕ ДАННЫЕ УСОПШЕГО</p>
          <ul className="nav">
            {this.props.tools.slice(2, 4).map(function (tool) {
              return (
                <li
                  className="nav-item"
                  key={tool.id}
                  style={{ marginBottom: "4px" }}
                >
                  <button
                    type="button"
                    className="tool"
                    data-toggle="tooltip"
                    title={tool.tooltip}
                    id={tool.id}
                    data-placement="bottom"
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                    }} // Flexbox для расположения
                    onClick={() => this.handleButtonClick(tool)} // Обработчик клика
                  >
                    <p className="tool-label">{tool.label}</p>
                    {/* SVG элемент */}
                    <svg
                      width="50"
                      height="5"
                      viewBox="0 0 50 5"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M47.6155 0L46.9171 0.707031L48.1942 2H0V3H48.0247L46.9171 4.12134L47.6155 4.82837L50 2.41431L47.6155 0Z"
                        fill="white"
                      />
                    </svg>
                  </button>
                </li>
              );
            }, this)}{" "}
            {/* Добавлено 'this' для доступа к контексту */}
          </ul>
        </div>

        {/* Блок для "Эпитафия" */}
        <div className="tool-block">
          <p className="tool-description">ПОДБЕРИТЕ СЛОВА</p>
          <ul className="nav">
            {this.props.tools.slice(4, 5).map(function (tool) {
              return (
                <li className="nav-item" key={tool.id}>
                  <button
                    type="button"
                    className="tool"
                    data-toggle="tooltip"
                    title={tool.tooltip}
                    id={tool.id}
                    data-placement="bottom"
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                    }} // Flexbox для расположения
                    onClick={() => this.handleButtonClick(tool)} // Обработчик клика
                  >
                    <p className="tool-label">{tool.label}</p>
                    {/* SVG элемент */}
                    <svg
                      width="50"
                      height="5"
                      viewBox="0 0 50 5"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M47.6155 0L46.9171 0.707031L48.1942 2H0V3H48.0247L46.9171 4.12134L47.6155 4.82837L50 2.41431L47.6155 0Z"
                        fill="white"
                      />
                    </svg>
                  </button>
                </li>
              );
            }, this)}{" "}
            {/* Добавлено 'this' для доступа к контексту */}
          </ul>
        </div>

        {/* Блок для "Крестик", "Цветок", "Свеча", "Птица", "Виньетка" */}
        <div className="tool-block">
          <p className="tool-description">ДОБАВЬТЕ ОФОРМЛЕНИЯ</p>
          <ul className="nav">
            {this.props.tools.slice(5, 10).map(function (tool) {
              return (
                <li
                  className="nav-item"
                  key={tool.id}
                  style={{ marginBottom: "4px" }}
                >
                  <button
                    type="button"
                    className="tool"
                    data-toggle="tooltip"
                    title={tool.tooltip}
                    id={tool.id}
                    data-placement="bottom"
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                    }} // Flexbox для расположения
                    onClick={() => this.handleButtonClick(tool)} // Обработчик клика
                  >
                    <p className="tool-label">{tool.label}</p>
                    {/* SVG элемент */}
                    <svg
                      width="50"
                      height="5"
                      viewBox="0 0 50 5"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M47.6155 0L46.9171 0.707031L48.1942 2H0V3H48.0247L46.9171 4.12134L47.6155 4.82837L50 2.41431L47.6155 0Z"
                        fill="#FFFFFF"
                      />{" "}
                      {/* Задайте цвет, если необходимо */}
                    </svg>
                  </button>
                </li>
              );
            }, this)}{" "}
            {/* Добавлено 'this' для доступа к контексту */}
          </ul>
        </div>

        <div className="tool-block">
          {/* Блок для инструментов */}
          {this.props.tools.slice(10, 13).map(function (tool) {
            return (
              <ul className="nav" style={{ marginBottom: "4px" }}>
                <li className="nav-item">
                  <button
                    type="button"
                    className="tool"
                    data-toggle="tooltip"
                    title={tool.tooltip}
                    id={tool.id}
                    data-placement="bottom"
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                    }} // Flexbox для расположения
                    onClick={() => this.handleButtonClick(tool)} // Обработчик клика
                  >
                    <p className="tool-label">{tool.label}</p>
                    {/* SVG элемент */}
                    <svg
                      width="50"
                      height="5"
                      viewBox="0 0 50 5"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M47.6155 0L46.9171 0.707031L48.1942 2H0V3H48.0247L46.9171 4.12134L47.6155 4.82837L50 2.41431L47.6155 0Z"
                        fill="white"
                      />
                    </svg>
                  </button>
                </li>
              </ul>
            );
          }, this)}
        </div>

        <div className="tool-block">
          <p className="tool-description">ПРИМЕРНАЯ СТОИМОСТЬ</p>
          <div id="priceList"></div> {/* Здесь выводится список стоимости */}
        </div>
      </div>
    );
  },
});

//---------------- main components -----------------

class PriceCalculator {
  constructor() {
    this.items = {};
    this.totalPrice = 0;
    this.displayNames = {
      // Map file patterns to display names
      front: "Памятник",
      photo: "Портрет",
      addpicture: "Портрет",
      cross: "Крестик",
      flower: "Цветок",
      candle: "Свеча",
      bird: "Пейзаж",
      vignette: "Виньетка",
      epitaph: "Эпитафия",
      name: "ФИО",
      date: "Дата",
    };
    this.prices = {
      // Monument prices
      "front1.png": 10000,
      "front2.png": 12000,
      "front3.png": 9000,
      "front4.png": 11000,
      "front5.png": 9500,
      "front6.png": 10000,
      "front7.png": 12000,
      "front8.png": 9000,
      "front9.png": 11000,
      "front10.png": 9500,
      "front11.png": 10000,
      "front12.png": 12000,
      // Photo prices
      "photo1.png": 7000,
      "photo2.png": 8000,
      "photo3.png": 6000,
      "photo4.png": 7500,
      // Other element prices remain unchanged...
      "epitaph1.png": 4000,
      "epitaph2.png": 4500,
      "epitaph3.png": 4200,
      "epitaph4.png": 4000,
      "epitaph5.png": 4500,
      "epitaph6.png": 4200,
      "epitaph7.png": 4000,
      "epitaph8.png": 4500,
      "epitaph9.png": 4200,
      "epitaph10.png": 4000,
      "epitaph11.png": 4500,
      "epitaph12.png": 4200,
      "epitaph13.png": 4200,
      "cross1.png": 2000,
      "cross2.png": 2000,
      "cross3.png": 2000,
      "cross4.png": 2000,
      "cross5.png": 2000,
      "cross6.png": 2000,
      "cross7.png": 2000,
      "cross8.png": 2000,
      "flower1.png": 2000,
      "flower2.png": 2000,
      "flower3.png": 2000,
      "flower4.png": 2000,
      "flower5.png": 2000,
      "flower6.png": 2000,
      "flower7.png": 2000,
      "flower8.png": 2000,
      "candle1.png": 2000,
      "candle2.png": 2000,
      "candle3.png": 2000,
      "candle4.png": 2000,
      "candle5.png": 2000,
      "candle6.png": 2000,
      "candle7.png": 2000,
      "candle8.png": 2000,
      "candle9.png": 2000,
      "bird1.png": 5000,
      "bird2.png": 5000,
      "bird3.png": 5000,
      "bird4.png": 5000,
      "bird5.png": 5000,
      "bird6.png": 5000,
      "bird7.png": 5000,
      "bird8.png": 5000,
      "bird9.png": 5000,
      "vignette1.png": 2000,
      "vignette2.png": 2000,
      "vignette3.png": 2000,
      "vignette4.png": 2000,
      "vignette5.png": 2000,
      "vignette6.png": 2000,
      "vignette7.png": 2000,
      "vignette8.png": 2000,
      "vignette9.png": 2000,
      "vignette10.png": 2000,
      "vignette11.png": 2000,
      "vignette12.png": 2000,
      "vignette13.png": 2000,
      "vignette14.png": 2000,
      "vignette15.png": 2000,
      "vignette16.png": 2000,
      "vignette17.png": 2000,
      "vignette18.png": 2000,
      "vignette19.png": 2000,
      "vignette20.png": 2000,
      // Special text prices
      name: 3000, // Price for name
      date: 1000, // Price for date
    };
  }

  getDisplayName(name) {
    // For special items like 'name' and 'date'
    if (this.displayNames[name]) {
      return this.displayNames[name];
    }

    // For files, check the prefix
    for (const [prefix, displayName] of Object.entries(this.displayNames)) {
      if (name.startsWith(prefix)) {
        return displayName;
      }
    }

    return name; // Fallback to original name
  }
  removeAllMonuments() {
    const monumentKeys = Object.keys(this.items).filter(
      (key) => key.startsWith("front") || key.includes("front")
    );
    for (const key of monumentKeys) {
      this.removeItem(key);
    }
  }

  addItem(item, customPrice) {
    // Extract base name for images
    const baseName = item.split("/").pop();

    // Determine price based on item type
    let price;
    if (customPrice !== undefined) {
      price = customPrice;
    } else if (item === "name") {
      price = this.prices["name"];
    } else if (item === "date") {
      price = this.prices["date"];
    } else {
      price = this.prices[baseName];
    }

    if (price) {
      // For monuments, remove any existing monument first
      if (baseName.startsWith("front")) {
        this.removeAllMonuments();
      }

      // Add new item price
      this.items[baseName || item] = price;
      this.totalPrice += price;
      this.updatePriceList();
    } else {
      console.warn(`Price not found for item: ${item}`);
    }
  }

  removeItem(item) {
    // Handle both full paths and base names
    const baseName = item.split("/").pop();
    const key = this.items[baseName] ? baseName : item;

    if (this.items[key]) {
      this.totalPrice -= this.items[key];
      delete this.items[key];
      this.updatePriceList();
    }
  }

  updatePriceList() {
    let priceList = "<ul class='price-list'>";
    for (let name in this.items) {
      const displayName = this.getDisplayName(name);
      priceList += `<li><span class='name'>${displayName}</span><span class='price'>${this.items[name]} ₽</span></li>`;
    }
    priceList += `<li class='total'><span class='name'><strong>Итого:</strong></span><span class='price'><strong>${this.totalPrice} ₽</strong></span></li>`;
    priceList += "</ul>";
    this.displayPriceList(priceList);
  }

  // Вывод списка на экран
  displayPriceList(priceList) {
    const element = document.getElementById("priceList");
    if (element) {
      element.innerHTML = priceList;
    }
  }
}

const priceCalculator = new PriceCalculator();

const style = document.createElement("style");
style.innerHTML = `
.price-list {
  list-style: none;
  padding-left: 0;
  font-size: 16px;
  color: #1E2C5C;
}
.price-list li {
  display: flex;
  justify-content: space-between;
  border-bottom: 2px solid #D9D9D933;
  padding: 8px 0;
}
.price-list .name {
  text-align: left;
}
.price-list .price {
  text-align: right;
}
.price-list .total {
  font-weight: bold;
}
`;
document.head.appendChild(style);

// Пример добавления изображения на канвас
editor.addImageToCanvas = function (imgSrc, x = 100, y = 100) {
  // Извлекаем имя изображения из пути
  const imageName = imgSrc.split("/").pop(); // Получаем имя изображения (например, flower.png)

  // Добавляем цену этого изображения в калькулятор
  priceCalculator.addItem(imageName);

  // Логика добавления изображения на канвас с использованием Fabric.js
  const img = new Image();
  img.onload = function () {
    const canvasImage = new fabric.Image(img, {
      left: x,
      top: y,
    });
    canvas.add(canvasImage);
  };
  img.src = imgSrc;
};

// Пример удаления элемента с канваса
editor.removeItemFromCanvas = function (element, imgSrc) {
  // Извлекаем имя изображения для удаления
  const imageName = imgSrc.split("/").pop(); // Получаем имя изображения (например, flower.png)

  // Убираем элемент из калькулятора
  priceCalculator.removeItem(imageName);

  // Логика удаления элемента с канваса
  canvas.remove(element);
};

var Header = React.createClass({
  render: function () {
    return (
      <div className="sidebar" data-html2canvas-ignore="true">
        {/* Боковая панель */}
        <div
          className="d-flex flex-column align-items-end"
          style={{ boxSizing: "border-box" }}
        >
          <ToolButtons tools={resources.tools} />
        </div>
      </div>
    );
  },
});

var Footer = React.createClass({
  render: function () {
    // Список изображений фронтов
    const frontImages = [
      "images/front1.png",
      "images/front2.png",
      "images/front3.png",
      "images/front4.png",
      "images/front5.png",
      "images/front6.png",
      "images/front7.png",
      "images/front8.png",
      "images/front9.png",
      "images/front10.png",
      "images/front11.png",
      "images/front12.png",
    ];

    return (
      <footer className="footer" data-html2canvas-ignore="true">
        {frontImages.map((src, index) => (
          <img
            key={index}
            src={src}
            alt={`Front ${index + 1}`}
            className="footer-image"
            onClick={() => editor.updateMonument(src)} // Вызываем обновление памятника
          />
        ))}
      </footer>
    );
  },
});

var Body = React.createClass({
  render: function () {
    return <div className="canvas" id="canvasDiv1"></div>;
  },
});

var EmptyContainer = React.createClass({
  render: function () {
    return <div className="container">&nbsp;</div>;
  },
});

var EmptyContainer80 = React.createClass({
  render: function () {
    return (
      <div className="container" data-html2canvas-ignore="true">
        &nbsp;
      </div>
    );
  },
});

var Modal = React.createClass({
  componentDidMount: function () {
    $(ReactDOM.findDOMNode(this)).modal("show");
    $(ReactDOM.findDOMNode(this)).on(
      "hidden.bs.modal",
      this.props.handleHideModal
    );
  },

  render: function () {
    return (
      <div className="modal fade" id="modal" data-html2canvas-ignore="true">
        <div className="modal-dialog">
          <div className="modal-content">
            <div className="modal-header">
              <button
                type="button"
                className="close"
                data-dismiss="modal"
                aria-label="Close"
              >
                <span aria-hidden="true">&times;</span>
              </button>
              <h4 className="modal-title" id="modalTitle"></h4>
            </div>
            <div className="modal-body row" id="modalBody"></div>
            <div className="modal-footer">
              <button
                type="button"
                className="btn btn-flat"
                data-dismiss="modal"
                id="cancelbutton"
              >
                Отмена
              </button>
              <button type="button" className="btn btn-flat" id="okbutton">
                Готово
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  },

  propTypes: {
    handleHideModal: React.PropTypes.func.isRequired,
  },
});

var App = React.createClass({
  getInitialState: function () {
    return { view: { showModal: false } };
  },
  handleHideModal: function () {
    this.setState({ view: { showModal: false } });
  },
  handleShowModal: function () {
    this.setState({ view: { showModal: true } });
  },
  componentDidMount: function () {
    //Onload
    editor.init();
  },

  render: function () {
    return (
      <div className="body-container">
        <div>
          <EmptyContainer80 />
          <Body />
          <EmptyContainer />
          <Footer />

          <button
            className="hidden"
            id="modalOpener"
            onClick={this.handleShowModal}
          >
            Open Modal
          </button>
          {this.state.view.showModal ? (
            <Modal handleHideModal={this.handleHideModal} />
          ) : null}
        </div>
        <Header />
      </div>
    );
  },
});

ReactDOM.render(<App />, document.getElementById("appwrapper"));
